Результат выполнения домашнего задания
["Работа в терминале, лекция 2"](https://github.com/netology-code/sysadm-homeworks/tree/devsys10/03-sysadmin-02-terminal)

1. Какого типа команда `cd`? Попробуйте объяснить, почему она именно такого типа; опишите ход своих мыслей, если считаете
что она могла бы быть другого типа.

Ответ: При вызове `type cd` мы увидим `cd is a shell builtin`. Это значит, что команда встроенная в оболочку.
Данная команда нужна для базовых операций с файловой системой, навигации по каталогам, именно поэтому она встроена.
Было бы очень странно, что для смены каталога, пришлось бы устанавливать дополнительный софт.

2. Какая альтернатива без pipe команде `grep <some_string> <some_file> | wc -l`?

Ответ: Альтернатива данной команде: `grep -c <some_string> <some_file>`

3. Какой процесс с PID `1` является родителем для всех процессов в вашей виртуальной машине Ubuntu 20.04?

Ответ: Для поиска родителя процессов можно воспользоваться командой `pstree -p` совместно с `grep`
Целиком команда будет выгдядеть данным образом:
```
vagrant@vagrant:~$ pstree -p | grep \(1\)
systemd(1)-+-VBoxService(865)-+-{VBoxService}(866)
```
А родителем всех процессов c PID `1` будет являться `systemd`

4. Как будет выглядеть команда, которая перенаправит вывод stderr `ls` на другую сессию терминала?
    
Ответ: для перенаправления вывода одного терминала в другой нужно открыть два терминала, через `tty` мы можем узнать
идентификатор сессии конкретного терминала:
```
vagrant@vagrant:~$ tty
/dev/pts/0
```
Для перенаправления воспользуемся командой: `ls /some/error/directory 2>&1`. Результат выполнения
двух терминалах ниже:
```
vagrant@vagrant:~$ tty
/dev/pts/0
vagrant@vagrant:~$ ls /some/error/dir 2>&1 1>&/dev/pts/1
vagrant@vagrant:~$
```
```
vagrant@vagrant:~$ tty
/dev/pts/1
vagrant@vagrant:~$ ls: cannot access '/some/error/dir': No such file or directory
```

5. Получится ли одновременно передать команде файл на `stdin` и вывести ее `stdout` в другой файл?
Приведите работающий пример.
    
Ответ: получится, к примеру на вход `grep` можно подать файл, в вывод сохранить в отдельный `stdout_file`
```
vagrant@vagrant:~$ echo 987654321 >> stdin_file
vagrant@vagrant:~$ grep 987 < stdin_file 1>& stdout_file
vagrant@vagrant:~$ cat stdout_file 
987654321
```

6. Получится ли находясь в графическом режиме, вывести данные из PTY в какой-либо из эмуляторов TTY?
Сможете ли вы наблюдать выводимые данные?

Ответ: да, вывод возможен, нужно открыть сессию терминала в графической оболочке и выполнить перенаправление потока
в целевой эмулятор `/dev/pts/<n>`. Данные можно увидеть если открыт терминал, подключенный к конкретной сессии.

7. Выполните команду `bash 5>&1`. К чему она приведет? Что будет, если вы выполните `echo netology > /proc/$$/fd/5`?
Почему так происходит?

Ответ: `bash 5>&1` - создаст новую терминальную сессию с перенаправлением потока `5` в `1`. Т.к. 5 довольно
нестандартный идентификатор потока, то будет создан файл `/proc/$$/fd/5`, который будет `stdout'ом`.
Поэтому команда `echo`, выведет содержимое в терминал.

8. Получится ли в качестве входного потока для pipe использовать только stderr команды, не потеряв при этом отображение
stdout на pty? Напоминаем: по умолчанию через pipe передается только stdout команды слева от | на stdin команды справа.
Это можно сделать, поменяв стандартные потоки местами через промежуточный новый дескриптор, который вы научились
создавать в предыдущем вопросе.
    
Ответ: получится, можно воспользоваться примером из предыдущего вопроса `bash 5>&1`,
а после этого выполнить перенаправление:
```
vagrant@vagrant:~$ ls /some/error/directory 2>&1 1>&5 | cat
ls: cannot access '/some/error/directory': No such file or directory
```
9. Что выведет команда `cat /proc/$$/environ`? Как еще можно получить аналогичный по содержанию вывод?

Ответ: команда выведет переменные окружения, аналогичным образом можно воспользоваться `env` или `printenv`

10. Используя `man`, опишите что доступно по адресам `/proc/<PID>/cmdline`, `/proc/<PID>/exe`

Ответ: `/proc/<PID>/cmdline` - это файл, доступный только для чтения, содержит полную командную строку для процесса,
если только процесс не является зомби. `/proc/<PID>/exe` - В Linux 2.2 и более поздних версиях этот файл представляет
собой символическую ссылку, содержащую фактический путь к выполняемой команде.

11. Узнайте, какую наиболее старшую версию набора инструкций SSE поддерживает ваш процессор с помощью `/proc/cpuinfo`.

Ответ: выполним `less /proc/cpuinfo | grep sse`, в выводе присутсвуют `sse`, `sse2`, `ssse3`, `sse4_1` и `sse4_2`.
Наиболее старшая из них `sse4_2`.

12. Почему `ssh localhost 'tty'` внутри виртуальной машины выдаёт ошибку `not a tty`

Ответ: из манула следует, что `localhost` - пункт назначения, куда будет осуществлено подключение,
а `tty` - команда, которая будет выполнена на удалённом сервере, без процедуры логина и отдельной сессии для пользователя.
Исправить это можно передав флаг `-t` - Force pseudo-terminal allocation. Или выполнив сначала подключение:
```shell
vagrant@vagrant:~$ ssh -t localhost 'tty'
vagrant@localhost's password: 
/dev/pts/2
Connection to localhost closed.
``` 
    
13. Бывает, что есть необходимость переместить запущенный процесс из одной сессии в другую.
Попробуйте сделать это, воспользовавшись `reptyr`. Например, так можно перенести в `screen` процесс,
который вы запустили по ошибке в обычной SSH-сессии.

Ответ: На удаленной машине не установлена утилита `reptyr`, для установки воспользуемся командой
`sudo apt install reptyr`. После установки запустим утилиту `screen`, она запустит новую сессию внутри себя.
Во втором подключении через ssh к удалённой машине запустим длительный процесс, например `top`. Внутри сессии `screen`
найдём нужынй нам процесс `lsof | grep top` и выполним захват его через `reptyr <PID>`.
Корректно перемещение отработало только в случае работы процессов в двух сесииях из под `root`.

14. Узнайте что делает команда `tee` и почему в отличие от `sudo echo` команда с `sudo tee` будет работать.

Ответ: команда `tee` читает стандартный поток ввода и пишет его в стандартный поток вывода и файлы.
Перенаправление в этом случае идёт в рамках одного процесса, именно поэтому `sudo tee` и будет работать.
